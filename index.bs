<pre class='metadata'>
Title: The Sec-Metadata HTTP Request Header
Shortname: sec-metadata
Level: 1
Status: DREAM
Editor: Mike West 56384, Google Inc., mkwst@google.com
!Explainer: https://github.com/mikewest/sec-metadata
Abstract:
    This document defines a `Sec-Metadata` HTTP request header that aims to provide servers with
    enough information to make <i lang="la">a priori</i> decisions about whether or not to service
    a request based on the way it was made, and the context in which it will be used.
Markup Shorthands: markdown yes
</pre>

<pre boilerplate="copyright">&copy;2018, Google, Inc. All rights reserved.</pre>

<pre class="biblio">
{
  "I-D.ietf-httpbis-header-structure": {
    "authors": [ "Mark Nottingham", "Poul-Henning Kamp" ],
    "href": "https://tools.ietf.org/html/draft-ietf-httpbis-header-structure",
    "title": "Structured Headers for HTTP",
    "status": "ID",
    "publisher": "IETF"
  }
}
</pre>

<pre class="anchors">
urlPrefix: https://tools.ietf.org/html/draft-ietf-httpbis-header-structure; spec: I-D.ietf-httpbis-header-structure
    type: dfn
        text: structured header; url: #
    for: structured header
        type: dfn
            text: dictionary; url: #section-3.1
        type: grammar
            text: identifier; url: #section-3.8
            text: string; url: #section-3.7
    type: abstract-op
        text: serialize Structured Header; url: #section-4.1
</pre>

<pre class="link-defaults">
spec:fetch; type:dfn; for:/; text:request
spec:fetch; type:dfn; text:main fetch
spec:url; type:dfn; for:/; text:url
</pre>

Introduction {#intro}
=====================

Interesting web applications generally end up with a large number of web-exposed endpoints that
might reveal sensitive data about a user, or take action on a user's behalf. Since users' browsers
can be easily convinced to make requests to those endpoints, and to include the users' ambient
credentials (cookies, privileged position on an intranet, etc), applications need to be very careful
about the way those endpoints work in order to avoid abuse.

Being careful turns out to be hard in some cases ("simple" CSRF), and practically impossible in
others (cross-site search, timing attacks, etc). The latter category includes timing attacks based
on the server-side processing necessary to generate certain responses, and length measurements (both
via web-facing timing attacks and passive network attackers).

It would be helpful if servers could make more intelligent decisions about whether or not to respond
to a given request based on the way that it's made in order to mitigate the latter category. For
example, it seems pretty unlikely that a "Transfer all my money" endpoint on a bank's server would
expect to be referenced from an <{img}> tag, and likewise unlikely that `evil.com` is going to be
making any legitimate requests whatsoever. Ideally, the server could reject these requests
<i lang="la">a priori</i> rather than delivering them to the application backend.

Here, we describe a mechanims by which user agents can enable this kind of decision-making by
adding additional context to outgoing requests. By delivering metadata to a server in a
<a http-header>`Sec-Metadata`</a> header, we enable applications to quickly reject requests based on
testing a set of preconditions. That work can even be lifted up above the application layer (to
reverse proxies, CDNs, etc) if desired.

Examples {#examples}
--------------------

A request generated by a <{picture}> element would result in a request containing the following
HTTP request header:

```
Sec-Metadata: destination=image, site=cross-site
```

A top-level navigation from `https://example.com` to `https://example.com/` caused by a user's click
on an in-page link would result in a request containing the following HTTP request header:

```
Sec-Metadata: cause=user-activated, destination=document, site=same-origin
```

Framework {#framework}
======================


The `Sec-Metadata` HTTP Request Header {#sec-metadata-header}
-------------------------------------------------------------

The <dfn http-header export>`Sec-Metadata`</dfn> HTTP request header containing a set of
interesting contextual information that allows a server to make more informed decisions about how
exactly it ought to respond to a given request.

`Sec-Metadata` is a [=Structured Header=]. Its value MUST be a [=structured header/dictionary=]
[[!I-D.ietf-httpbis-header-structure]]. The header is parsed according to the rules laid out in
<a href="https://tools.ietf.org/html/draft-ietf-httpbis-header-structure#section-3">Section 3</a>
of that document.

The dictionary MAY contain one or more of the members defined in detail below. Servers MUST ignore
unknown members, and members whose value is invalid.

### The `cause` Member ### {#cause-member}

[=Navigation requests=] will contain a dictionary member whose key is
"<dfn dict-member for="Sec-Metadata">`cause`</dfn>", and whose value is an
<a for="structured header" grammar>`identifier`</a>. Other kinds of requests will not contain a
{{Sec-Metadata/cause}} member.

Valid {{Sec-Metadata/cause}} values are `user-activated` and `forced`, representing whether or not
a given request was [=triggered by user activation=].

<div algorithm="get cause">

To <dfn abstract-op local-lt="get cause">obtain the `cause` value</dfn> for a [=request=] |r|:

1.  If |r| is a [=navigation request=]:

    1.  If |r| was [=triggered by user activation=], return `user-activated`.

        ISSUE: We probably need to pipe this value through from HTML's navigation algorithm to
        Fetch so we can read it off the [=request=] here.

    2.  Return `forced`.

2.  Return `null`.

</div>


### The `destination` Member ### {#destination-member}

All requests will contain a dictionary member whose key is
"<dfn dict-member for="Sec-Metadata">`destination`</dfn>", and whose value is a
<a for="structured header" grammar>`identifier`</a> representing the [=request=]'s
[=request/destination=], or the empty <a for="structured header" grammar>`string`</a>.

Valid {{Sec-Metadata/destination}} values include all valid [=request=] [=request/destination=]
values (the empty string, "`audio`", "`audioworklet`", "`document`", "`embed`", "`font`",
"`image`", "`manifest`", "`object`", "`paintworklet`", "`report`", "`script`", "`serviceworker`",
"`sharedworker`", "`style`", "`track`", "`video`", "`worker`", "`xslt`", or "`nested-document`").

ISSUE(whatwg/fetch#755): Fetch currently does not define `nested-document`. It would be ideal if
we could add it, as the `target` member doesn't seem to be web-compatible.

ISSUE: Perhaps we should define a specific identifier for the empty string, rather than switching
types from `identifier` to `string` for the empty destination?

<div algorithm="get destination">
    To <dfn abstract-op local-lt="get destination">obtain the `destination` value</dfn> for a
    [=request=] (|r|), return |r|'s [=request/destination=]. 
</div>

<pre class="example">
// `fetch()`'s destination is the empty string:
Sec-Metadata: ..., destination="", ...

// `<img>`'s destination is "image"
Sec-Metadata: ..., destination="image", ...

// `new Worker()`'s destination is "worker"
Sec-Metadata: ..., destination="worker", ...

// Navigations' destinations are "document"
Sec-Metadata: ..., destination="document", ...
</pre>

### The `site` Member ### {#site-member}

All requests will contain a dictionary member whose key is
"<dfn dict-member for="Sec-Metadata">`site`</dfn>", and whose value is an
<a for="structured header" grammar>`identifier`</a> representing the relationship between the
[=request=]'s [=request/origin=] and the [=url/origins=] for the [=URLs=] in the [=request=]'s
[=request/url list=].

Valid {{Sec-Metadata/site}} values are `same-origin`, `same-site`, and `cross-site`.

<div algorithm="get site">
    To <dfn abstract-op local-lt="get site">obtain the `site` value</dfn> for a [=request=] (|r|):

    1.  Let |site| be `same-origin`.

    2.  For each |url| in |r|'s [=request/url list=]:

        1.  If |url| is [=same origin=] with |r|'s [=request/origin=], continue.

        2.  If |r|'s [=request/origin=]'s [=registrable domain=] is not the same as |url|'s
            [=registrable domain=], return `cross-site`.

        3.  Set |site| to `same-site`.

    3.  Return |site|.
</div>

Integration With Fetch {#fetch-integration}
-------------------------------------------

<div algorithm="set the header">
To <dfn abstract-op>set the `Sec-Metadata` header for a request</dfn>, given a [=request=] |r|:

<ol class="algorithm">
    1.  If |r|'s [=request/url=] is not an [=potentially trustworthy URL=], return.

    2.  Let |header| be a [=Structured Header=] whose value is a [=structured header/dictionary=]. 

    3.  If |r| is a [=navigation request=]:

        1.  Append an item to |header| whose key is {{Sec-Metadata/cause}}, and whose value is the
            result of [$get cause|obtaining the cause value$] for |r|.

    4.  Append an item to |header| whose key is {{Sec-Metadata/destination}}, and whose value is the
        result of [$get destination|obtaining the destination value$] for |r|.

    5.  Append an item to |header| whose key is {{Sec-Metadata/site}}, and whose value is the result
        of [$get site|obtaining the site value$] for |r|.

    6.  Let |value| be the result of [$serialize Structured Header|serializing$] |header|.

    7.  [=header list/Set=] &#96;<a http-header>`Sec-Metadata`</a>&#96;/|value| in |r|'s [=request/header list=].
</ol>
</div>

Fetch will call into the algorithm above from within its [=main fetch=] algorithm. Please consult
that specification for integration details [[!FETCH]].

ISSUE: Monkey patching! I should file a bug.

Security and Privacy Considerations {#sec-priv-considerations}
==============================================================

Redirects {#redirects}
----------------------

The user agent will send a <a http-header>`Sec-Metadata`</a> header along with each request in a
redirect chain. Most of the values will remain consistent across redirects (e.g. the
{{Sec-Metadata/destination}} won't change), but the {{Sec-Metadata/site}} value will shift in the
presence of cross-origin or cross-site redirection in order to mitigate confusion.

The algorithm to [$obtain the site value$] walks the [=request=]'s entire [=request/url list=],
and will return `cross-site` if any URL in the list is cross-site to the request's current
[=request/current url=], `same-site` only if all URLs in the list are same-site with the request's
[=request/current url=], and `same-origin` only if all URLs in the list are same-origin with the request's
[=request/current url=].

For example, if `https://example.com/` requests `https://example.com/redirect`, the initial
request's {{Sec-Metadata/site}} value would be `same-origin`. If that response redirected to
`https://subdomain.example.com/redirect`, that request's {{Sec-Metadata/site}} value would be
`same-site` (as `https://subdomain.example.com/` and `https://example.com/` have the same
registrable domain). If that response redirected to `https://example.net/redirect`, that
request's {{Sec-Metadata/site}} value would be `cross-site` (as `https://example.net/` is not
same-site with `https://example.com/` and `https://subdomain.example.com/`). If that response
redirects all the way back to `https://example.com/`, the final request's {{Sec-Metadata/site}}
value would still be `cross-site` (as the redirect chain includes `https://example.net/`, which is
still not same-site with the other URLs.

Deployment Considerations {#deployment-considerations}
======================================================

Vary {#vary}
------------

If a given endpoint's response depends upon the values the client delivers in a
<a http-header>`Sec-Metadata`</a> header, developers should be careful to include an appropriate
`Vary` header [[RFC7231]], in order to ensure that caches handle the response appropriately. For
example, `Vary: Accept-Encoding, Sec-Metadata`.

IANA Considerations {#iana}
===========================

The permanent message header field registry should be updated with the following registration for
the <a http-header>`Sec-Metadata`</a> header: [[!RFC3864]]

:   Header field name
::  Sec-Metadata
:   Applicable protocol
::  http
:   Status
::  standard
:   Author/Change controller
::  Me
:   Specification document
::  This specification (See [[#sec-metadata-header]])
